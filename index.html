<!DOCTYPE html>
<html lang="lt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mažeikių Nafta – SVF Analizė</title>
    <meta name="description" content="Orlen Lietuva interesų vektorių vizualizacija. Submerged Vector Framework.">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Tufte-inspired: high data-ink ratio, minimal chartjunk */
        :root {
            --ink: #2c2c2c;
            --ink-light: #555;
            --ink-muted: #888;
            --paper: #fffff8;
            --accent: #a00;
            --link: #004d99;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'ET Book', Palatino, 'Palatino Linotype', 'Book Antiqua', Georgia, serif;
            background: var(--paper);
            color: var(--ink);
            line-height: 1.6;
            padding: 2rem 1rem;
            font-size: 16px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Typography - Tufte style */
        h1 {
            font-size: 2.2rem;
            font-weight: 400;
            margin-bottom: 0.3rem;
            letter-spacing: -0.02em;
        }
        h2 {
            font-size: 1.4rem;
            font-weight: 400;
            font-style: italic;
            margin: 2rem 0 0.8rem;
            color: var(--ink);
        }
        h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 1.5rem 0 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--ink-light);
        }
        .subtitle {
            color: var(--ink-muted);
            font-style: italic;
            margin-bottom: 0.5rem;
        }
        .framework-ref {
            font-size: 0.85rem;
            color: var(--link);
            text-decoration: none;
            border-bottom: 1px solid transparent;
        }
        .framework-ref:hover {
            border-bottom-color: var(--link);
        }
        p { margin-bottom: 1rem; max-width: 55rem; }
        strong { font-weight: 600; }

        /* Sidenotes - Tufte signature */
        .sidenote {
            float: right;
            clear: right;
            margin-right: -45%;
            width: 40%;
            font-size: 0.85rem;
            line-height: 1.4;
            color: var(--ink-muted);
            padding-left: 1rem;
        }
        .sidenote-number {
            font-size: 0.7rem;
            vertical-align: super;
            color: var(--accent);
        }
        @media (max-width: 1100px) {
            .sidenote {
                display: block;
                float: none;
                width: 100%;
                margin: 0.5rem 0 1rem 1.5rem;
                padding-left: 0.5rem;
                border-left: 2px solid #ddd;
            }
        }

        /* Epigraph */
        .epigraph {
            margin: 1.5rem 0 2rem;
            padding-left: 2rem;
        }
        .epigraph blockquote {
            font-style: italic;
            color: var(--ink-light);
            margin-bottom: 0.3rem;
        }
        .epigraph .attribution {
            font-size: 0.85rem;
            color: var(--ink-muted);
        }

        /* Main layout */
        .main-content {
            display: grid;
            grid-template-columns: 55% 1fr;
            gap: 3rem;
            margin: 2rem 0;
            align-items: start;
        }
        @media (max-width: 900px) {
            .main-content { grid-template-columns: 1fr; }
        }

        /* Visualization - clean, minimal chrome */
        .viz-container {
            background: #f8f8f5;
            border: 1px solid #e0e0e0;
            position: relative;
        }
        #three-container {
            width: 100%;
            height: 420px;
            cursor: grab;
        }
        #three-container:active { cursor: grabbing; }
        
        .viz-caption {
            padding: 0.8rem 1rem;
            font-size: 0.85rem;
            color: var(--ink-muted);
            border-top: 1px solid #e0e0e0;
        }
        
        /* Minimal legend - integrated */
        .viz-legend {
            position: absolute;
            top: 12px;
            left: 12px;
            font-size: 0.75rem;
            line-height: 1.6;
            color: var(--ink-light);
        }
        .viz-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .viz-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        .viz-sum {
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid #ccc;
            font-weight: 600;
        }

        /* Axes - subtle */
        .viz-axes {
            position: absolute;
            bottom: 50px;
            right: 12px;
            font-size: 0.7rem;
            color: var(--ink-muted);
            text-align: right;
            line-height: 1.5;
        }

        /* Toggle - minimal */
        .whatif-toggle {
            position: absolute;
            top: 12px;
            right: 12px;
        }
        .whatif-btn {
            background: none;
            border: 1px solid var(--ink-muted);
            color: var(--ink);
            padding: 4px 10px;
            font-size: 0.75rem;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
        }
        .whatif-btn:hover {
            border-color: var(--ink);
        }
        .whatif-btn.active {
            background: var(--ink);
            color: var(--paper);
        }
        .mode-label {
            font-size: 0.7rem;
            color: var(--ink-muted);
            margin-top: 4px;
            text-align: right;
        }

        /* Agent table - Tufte style, no gridlines */
        .agent-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
            margin: 1rem 0;
        }
        .agent-table th {
            text-align: left;
            font-weight: 400;
            font-style: italic;
            padding: 0.5rem 0.8rem 0.5rem 0;
            border-bottom: 1px solid var(--ink);
            color: var(--ink-muted);
        }
        .agent-table td {
            padding: 0.6rem 0.8rem 0.6rem 0;
            vertical-align: top;
            border-bottom: 1px solid #eee;
        }
        .agent-table tr:last-child td {
            border-bottom: 1px solid var(--ink);
        }
        .agent-name {
            font-weight: 600;
            white-space: nowrap;
        }
        .submerged { color: var(--ink-muted); font-size: 0.85rem; }
        .surface { font-style: italic; font-size: 0.85rem; }

        /* Two-column for theory */
        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 1.5rem 0;
        }
        @media (max-width: 700px) {
            .two-col { grid-template-columns: 1fr; }
        }

        /* Transformation table */
        .transform-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            margin: 1rem 0;
        }
        .transform-table th {
            text-align: left;
            font-weight: 400;
            font-style: italic;
            padding: 0.4rem 0.6rem 0.4rem 0;
            border-bottom: 1px solid var(--ink);
        }
        .transform-table td {
            padding: 0.4rem 0.6rem 0.4rem 0;
            border-bottom: 1px solid #eee;
        }
        .transform-table .arrow { text-align: center; color: var(--ink-muted); }

        /* PESTEL - minimal grid */
        .pestel-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
        }
        .pestel-item {
            flex: 1 1 140px;
            padding: 0.6rem;
            background: #f5f5f0;
            font-size: 0.8rem;
        }
        .pestel-item strong {
            display: block;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            color: var(--ink-muted);
            margin-bottom: 0.2rem;
        }

        /* Footer */
        footer {
            margin-top: 3rem;
            padding-top: 1rem;
            border-top: 1px solid #ddd;
            font-size: 0.8rem;
            color: var(--ink-muted);
        }
        footer a { color: var(--link); text-decoration: none; }

        /* Spark line style for inline data */
        .inline-data {
            font-variant-numeric: tabular-nums;
            color: var(--ink-light);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Mažeikių Nafta</h1>
            <p class="subtitle">Interesų vektoriai ir emergentinis elgesys</p>
            <a href="https://github.com/HackrsValv/mn-vektoriai" class="framework-ref">Submerged Vector Framework (SVF)</a>
        </header>

        <div class="epigraph">
            <blockquote>
                "The ensemble behaves in ways not predicted by the components. 
                The interactions matter more than the nature of the units."
            </blockquote>
            <div class="attribution">— N.N. Taleb</div>
        </div>

        <p>
            Orlen Lietuva atvejis iliustruoja bendrą multi-agent sistemų problemą: 
            <strong>stebimas elgesys yra vektorių suma</strong>, kurios joks atskiras dalyvis nesiekė.
            <span class="sidenote-number">1</span>
            <span class="sidenote">
                Kiekvienas agentas optimizuoja savo poziciją racionaliai. 
                Bet suma — emergentinis rezultatas — gali būti suboptimali visiems. 
                Tai Olson'o (1965) kolektyvinio veiksmo problema.
            </span>
        </p>

        <div class="main-content">
            <div class="viz-container">
                <div id="three-container"></div>
                <div class="viz-legend">
                    <div class="viz-legend-item"><span class="viz-dot" style="background:#c44;"></span> Orlen</div>
                    <div class="viz-legend-item"><span class="viz-dot" style="background:#ca0;"></span> LT valstybė</div>
                    <div class="viz-legend-item"><span class="viz-dot" style="background:#4a4;"></span> Darbuotojai</div>
                    <div class="viz-legend-item"><span class="viz-dot" style="background:#48c;"></span> Vadovybė</div>
                    <div class="viz-legend-item"><span class="viz-dot" style="background:#84c;"></span> Tiekėjai</div>
                    <div class="viz-legend-item viz-sum"><span class="viz-dot" style="background:#068;"></span> Σ Elgesys</div>
                </div>
                <div class="viz-axes">
                    X: pelnas →<br>
                    Y: valdžia ↑<br>
                    Z: augimas ↗
                </div>
                <div class="whatif-toggle">
                    <button class="whatif-btn" id="whatifBtn">WHAT IF?</button>
                    <div class="mode-label" id="modeLabel">submerged</div>
                </div>
                <div class="viz-caption">
                    Punktyrinės linijos = paslėpti (submerged) interesai. 
                    Ištisinė = suma, t.y. stebimas elgesys. 
                    Tempk pele sukti.
                </div>
            </div>

            <div>
                <h3>Agentai</h3>
                <table class="agent-table">
                    <thead>
                        <tr>
                            <th>Kas</th>
                            <th>Submerged</th>
                            <th>Surface</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="agent-name" style="color:#c44;">Orlen</td>
                            <td class="submerged">Max dividendai, PL strategija</td>
                            <td class="surface">„Optimizuojame portfelį"</td>
                        </tr>
                        <tr>
                            <td class="agent-name" style="color:#ca0;">LT valstybė</td>
                            <td class="submerged">Politiniai taškai, rinkėjai</td>
                            <td class="surface">„Giname interesus"</td>
                        </tr>
                        <tr>
                            <td class="agent-name" style="color:#4a4;">Darbuotojai</td>
                            <td class="submerged">Darbo vieta, paskola, vaikai</td>
                            <td class="surface">„Reikalaujame sąžiningumo"</td>
                        </tr>
                        <tr>
                            <td class="agent-name" style="color:#48c;">Vadovybė</td>
                            <td class="submerged">Bonusas, karjera Orlen grupėje</td>
                            <td class="surface">„Vykdome strategiją"</td>
                        </tr>
                        <tr>
                            <td class="agent-name" style="color:#84c;">Tiekėjai</td>
                            <td class="submerged">Ilgi kontraktai, lock-in</td>
                            <td class="surface">„Siūlome patikimą tiekimą"</td>
                        </tr>
                    </tbody>
                </table>
                
                <p style="font-size: 0.85rem; color: var(--ink-muted);">
                    <strong>Σ Elgesys</strong> = tai, ką stebime. 
                    Vektorius (priežastis) — tik spėjame.
                </p>
            </div>
        </div>

        <h2>Kodėl problema išlieka?</h2>
        
        <p>
            Visi dalyviai žino, kad paslėpti interesai kuria neefektyvumą.
            <span class="sidenote-number">2</span>
            <span class="sidenote">
                „In an opaque system, operators have an incentive to hide risk, 
                taking upside without downside." — Taleb (2018)
            </span>
            Bet sistema nesikeičia. Priežastis: jei esi sistemos <em>dalis</em>, 
            matai ją ribotai — tik per savo poziciją. Optimizuoji savo vietą, 
            ir tau tai racionalu. Pakeisti sistemą reikštų pralaimėti individualiai.
        </p>

        <h2>Two-Pass sprendimas</h2>

        <div class="two-col">
            <div>
                <h3>Pass 1: Legitimization</h3>
                <p>
                    Ištransliuoti submerged į surface. Ne „demaskuoti", 
                    o sukurti aplinką, kur tikri interesai yra legitimūs:
                </p>
                <ul style="font-size: 0.9rem; margin-left: 1.2rem;">
                    <li>Orlen: „Norime max ROI" → OK</li>
                    <li>Vadovybė: „Norime bonusų" → OK</li>
                    <li>Darbuotojai: „Norime stabilumo" → OK</li>
                    <li>LT: „Norime politinių taškų" → OK</li>
                </ul>
            </div>
            <div>
                <h3>Pass 2: Transformation</h3>
                <p>
                    Surasti mechanizmus, kur A interesai patenkinami per B interesus. 
                    Ne kompromisas (visi pralaimi), o dizainas (visi laimi):
                </p>
                <table class="transform-table">
                    <tr>
                        <td>Orlen kapitalas</td>
                        <td class="arrow">→</td>
                        <td>LT darbo vietos</td>
                    </tr>
                    <tr>
                        <td>LT reguliacinė erdvė</td>
                        <td class="arrow">→</td>
                        <td>Orlen lankstumas</td>
                    </tr>
                    <tr>
                        <td>Darbuotojų lojalumas</td>
                        <td class="arrow">→</td>
                        <td>Vadovybės stabilumas</td>
                    </tr>
                </table>
            </div>
        </div>

        <div class="epigraph" style="margin-top: 2rem;">
            <blockquote>
                "You must eat your own cooking."
            </blockquote>
            <div class="attribution">— Taleb, apie skin in the game</div>
        </div>

        <h2>PESTEL kontekstas</h2>
        <div class="pestel-row">
            <div class="pestel-item"><strong>Political</strong>LT-PL santykiai, ES politika, sankcijos</div>
            <div class="pestel-item"><strong>Economic</strong>Naftos kainos, EUR/USD, infliacija</div>
            <div class="pestel-item"><strong>Social</strong>Darbo jėga, emigracija, bendruomenė</div>
            <div class="pestel-item"><strong>Tech</strong>Modernizacija, žalioji energetika</div>
            <div class="pestel-item"><strong>Environ</strong>CO₂ mokesčiai, taršos leidimai</div>
            <div class="pestel-item"><strong>Legal</strong>ES direktyvos, darbo kodeksas</div>
        </div>

        <h2>Teorinis pagrindas</h2>
        <p>
            SVF remiasi: Taleb (2018) — skin in the game ir hidden asymmetries; 
            Olson (1965) — kolektyvinio veiksmo logika; 
            von Foerster — antros eilės kibernetika (stebėtojas yra sistemos dalis);
            Ashby — requisite variety dėsnis.
            <span class="sidenote-number">3</span>
            <span class="sidenote">
                Taip pat susiję AI alignment darbai: 
                MAEBE Framework (2025) apie multi-agent emergent behavior; 
                Emergent Alignment via Competition apie convex hull of utilities.
            </span>
        </p>

        <footer>
            <strong>Submerged Vector Framework (SVF)</strong><br>
            Agent-agnostic metodika emergentinio elgesio analizei · 
            <a href="https://github.com/HackrsValv/mn-vektoriai">GitHub</a> · 2025
        </footer>
    </div>

    <script>
        // Three.js — minimal, functional
        const container = document.getElementById('three-container');
        const w = container.clientWidth, h = container.clientHeight;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8f8f5);

        const camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 1000);
        camera.position.set(5, 3.5, 5);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(w, h);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Subtle grid
        const grid = new THREE.GridHelper(5, 10, 0xcccccc, 0xe5e5e0);
        scene.add(grid);

        // Origin point
        const origin = new THREE.Vector3(0, 0, 0);
        const dotGeo = new THREE.SphereGeometry(0.05, 12, 12);
        const dotMat = new THREE.MeshBasicMaterial({ color: 0x666666 });
        scene.add(new THREE.Mesh(dotGeo, dotMat));

        // Vector creation — cleaner
        function makeVector(end, color, dashed = false) {
            const group = new THREE.Group();
            const dir = end.clone().normalize();
            const len = end.length();

            // Line
            const mat = dashed
                ? new THREE.LineDashedMaterial({ color, dashSize: 0.12, gapSize: 0.08, transparent: true, opacity: 0.6 })
                : new THREE.LineBasicMaterial({ color, linewidth: 2 });
            const geo = new THREE.BufferGeometry().setFromPoints([origin, end]);
            const line = new THREE.Line(geo, mat);
            if (dashed) line.computeLineDistances();
            group.add(line);

            // Arrowhead
            const coneGeo = new THREE.ConeGeometry(0.06, 0.18, 6);
            const coneMat = new THREE.MeshBasicMaterial({ color, transparent: dashed, opacity: dashed ? 0.6 : 1 });
            const cone = new THREE.Mesh(coneGeo, coneMat);
            cone.position.copy(end);
            const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
            cone.setRotationFromQuaternion(q);
            group.add(cone);

            return group;
        }

        // Data — Tufte colors (muted, distinguishable)
        const vectors = [
            { end: new THREE.Vector3(1.6, 0.9, 1.1), color: 0xcc4444 },  // Orlen
            { end: new THREE.Vector3(-1.2, 0.3, -0.9), color: 0xccaa00 }, // LT
            { end: new THREE.Vector3(-0.7, -1.0, 0.2), color: 0x44aa44 }, // Darbuotojai
            { end: new THREE.Vector3(1.0, 1.2, 0.3), color: 0x4488cc },   // Vadovybė
            { end: new THREE.Vector3(0.7, -0.5, 0.9), color: 0x8844cc },  // Tiekėjai
        ];

        const alignedVectors = [
            { end: new THREE.Vector3(0.7, 0.4, 0.5), color: 0xcc4444 },
            { end: new THREE.Vector3(-0.3, 0.4, 0.2), color: 0xccaa00 },
            { end: new THREE.Vector3(0.1, 0.2, 0.35), color: 0x44aa44 },
            { end: new THREE.Vector3(0.4, 0.3, 0.4), color: 0x4488cc },
            { end: new THREE.Vector3(0.25, 0.1, 0.35), color: 0x8844cc },
        ];

        let currentObjects = [];
        let sumObject = null;

        function renderVectors(data, dashed) {
            currentObjects.forEach(o => scene.remove(o));
            if (sumObject) scene.remove(sumObject);
            currentObjects = [];

            const sum = new THREE.Vector3();
            data.forEach(v => {
                const obj = makeVector(v.end, v.color, dashed);
                scene.add(obj);
                currentObjects.push(obj);
                sum.add(v.end);
            });

            sumObject = makeVector(sum, 0x006688, false);
            scene.add(sumObject);
        }

        renderVectors(vectors, true);

        // Interaction
        let dragging = false, prevX = 0, prevY = 0, rotX = 0, rotY = 0;

        container.addEventListener('mousedown', e => { dragging = true; prevX = e.clientX; prevY = e.clientY; });
        container.addEventListener('mousemove', e => {
            if (!dragging) return;
            rotY += (e.clientX - prevX) * 0.005;
            rotX += (e.clientY - prevY) * 0.005;
            prevX = e.clientX; prevY = e.clientY;
        });
        container.addEventListener('mouseup', () => dragging = false);
        container.addEventListener('mouseleave', () => dragging = false);

        container.addEventListener('touchstart', e => { dragging = true; prevX = e.touches[0].clientX; prevY = e.touches[0].clientY; });
        container.addEventListener('touchmove', e => {
            if (!dragging) return;
            rotY += (e.touches[0].clientX - prevX) * 0.005;
            rotX += (e.touches[0].clientY - prevY) * 0.005;
            prevX = e.touches[0].clientX; prevY = e.touches[0].clientY;
        });
        container.addEventListener('touchend', () => dragging = false);

        function animate() {
            requestAnimationFrame(animate);
            if (!dragging) { rotX *= 0.95; rotY *= 0.95; }
            scene.rotation.x += rotX * 0.1;
            scene.rotation.y += rotY * 0.1;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            const nw = container.clientWidth, nh = container.clientHeight;
            camera.aspect = nw/nh;
            camera.updateProjectionMatrix();
            renderer.setSize(nw, nh);
        });

        // Toggle
        let aligned = false;
        const btn = document.getElementById('whatifBtn');
        const label = document.getElementById('modeLabel');

        btn.addEventListener('click', () => {
            aligned = !aligned;
            btn.classList.toggle('active', aligned);
            btn.textContent = aligned ? 'RESET' : 'WHAT IF?';
            label.textContent = aligned ? 'aligned' : 'submerged';
            renderVectors(aligned ? alignedVectors : vectors, !aligned);
        });
    </script>
</body>
</html>
